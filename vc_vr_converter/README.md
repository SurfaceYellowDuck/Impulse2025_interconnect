# Преобразователь valid/credit интерфейса в valid/ready интерфейс
- Описание принятых при проектировании решений:

С одной стороны модуль предоставляет передатчику определенное количество кредитов. Один кредит - одна транзакция. С другой стороны - приемник, работающий по протоколу valid-ready. Когда он готов принимать данные - он выставляет сигнал ready в единицу. Транзакция происходит, если данные на передатчике valid и приемник ready, т.е. когда происходит хендшейк. Поскольку сигнал ready не всегда должен быть в единице, возникает необходимость остановки передачи данных с приемника. Поскольку сторона "приемник - конвертер" работает по протоколу valid-credit, моментальная остановка передачи данных невозможна, возникает необходимость сохранения данных до момента, пока кредиты у передатчика не закончатся. 
Для обеспечения сохранности данных можно использовать сдвиговый регистр, а также можно использовать FIFO. При проектировании модуля было принято решение использовать FIFO, поскольку его энергопотребление ниже, чем у сдвигового регистра, а также у него выше пропускная способность. Для примера можно представить ситуацию, при которой сдвиговый регистр был заполнен полностью, затем передатчик по какой-либо причине перестал передавать данные какое-то количество тактов, а затем снова начал писать в регистр. Это привело бы к образованию пузырька внутри сдвигового регистра, появилась бы необходимость ждать валидные данные несколько тактов. FIFO избавляет нас от необходимости ждать некоторое количество тактов, и выдает данные когда они есть, и их готовы принимать.


- Идейная схема модуля(некоторые сигналы опущены специально):

<img src="https://github.com/SurfaceYellowDuck/Impulse2025_interconnect/blob/main/images/chema_upd.png" width="500">

- Описание работы спроектированных модулей:

Со стороны "передатчик-конвертер" приходят следующие сигналы: clk, rst_n, s_data_i, s_valid_i. На сторону "конвертер-передатчик" приходит сигнал выдачи кредита. Через такт после сброса конвертер выдает передатчику все кредиты по одному. Если приемник передает данные, и при этом данные читаются из FIFO - количество кредитов уменьшаться в этом такте не будет. Если же данные не передаются - кредиты уменьшаются. Это особенно важно в начальный промежуток времени, пока мы не успели отдать все кредиты передатчику.
В дальнейшем кредиты выдаются приемнику сразу после чтения из FIFO.

Между приемником и передатчиком внутри конвертера находится FIFO. Он принимает данные, если они валидны и буфер он не полон. Выдаются данные при их наличии и готовности приемника, за это отвечает сигнал fifo_pop. При этом сигнал valid не ожидает сингнал ready, и выставляется всегда, если FIFO не пуст. Это корректно, т.к. в FIFO попадают только валидные данные.

Данные передаются на выход в том же порядке, в котором они поступили на вход, это обеспечивается логикой FIFO. Внутри FIFO выходы full и empty регистровые. Это хорошо, т.к. может немного увеличить пропускную способность блока, но что более важно, эти сигналы являются управляющими. И если бы они выходили из этого FIFO в другой тактовый домен, их так или иначе пришлось бы регистровать, поскольку тянуть комбинационную логику из одного тактового домена в другой - плохо, и может привести к неправильному поведению схемы.

Тестовое окружение написано так, чтобы воспроизвести ситуацию, которая изображена на временной диаграмме в описании тестового задания. Также оно проверяет поведение блока при попытке записи данных в заполненное FIFO, и запись невалидных данных.

Чтобы скомпилировать модуль введите в терминале:
```
make compile
```

Чтобы запустить симуляцию введите в терминале:
```
make simulate
```